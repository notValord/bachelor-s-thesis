/**
* Project name: Effective reduction of Finite Automata
* Author: Veronika Molnárová
* Date: 06.05.2023
* Subject: Bachelor's thesis - 1st part
*/

#ifndef BAKALARKA_AUTO_LANGUAGE_CHECK_H
#define BAKALARKA_AUTO_LANGUAGE_CHECK_H

#include "det_auto.h"

/***
 *  Checks whether the language of one automaton is a subset of the language of the second automaton
 * @return          true if the first language is subset fo the second one, else returns false
 */
bool language_intersect(const std::shared_ptr <det_auto>&, const std::shared_ptr <det_auto>&);

/***
 * Checks whether the two given automata define the same language through creating complements,
 *  uses language_intersect
 * @return          true if the automata are language equivalent else returns false
 */
bool language_equal(const std::shared_ptr <det_auto>&, const std::shared_ptr <det_auto>&);

/***
 * Part where the subset of the language is checked when comparing languages, additionally saves words
 *  that the automaton incorrectly accepts or rejects
 * @param first         the automaton generated by the solver
 * @param second        the original automaton to which the language is compared to
 * @param add           vector to which the found words are stored to
 * @return              true if the language of the first automaton is a subset of the second automaton
 */
bool sat_intersect(const std::shared_ptr <det_auto>& first, const std::shared_ptr <det_auto>& second,
                   std::vector <std::queue<unsigned int>>* add);
/***
 * Checks whether the two given automata define the same language through creating complements,
 *  uses language_intersect, additionally finds words that the automaton incorrectly accepts or rejects,
 *  uses sat_intersect
 * @param sat           the automaton generated by the solver
 * @param orig          the original automaton to which the language is compared to
 * @param output        the automata_stats object where the found words are stored
 * @return              true if the languages are equal and no words were found, else false is returned
 */
bool sat_equal(const std::shared_ptr <det_auto>& sat, const std::shared_ptr <det_auto>& orig,
               const std::shared_ptr <automata_stats>& output);

/***
 * Function needed fro checking whether the newly created product of antichains should be searched further
 *  for words or it is not worth and the searching in this branch is stopped
 * @param covering          vector of products that were already visited
 * @param state             the state of the product state
 * @param product           the product of the product state
 * @return                  true if the resolution should continue and the product stated added to be visited,
 *                              else returns false
 */
bool check_product(std::vector <std::pair <int, std::set <int>>>& covering, int state, std::set <int>& product);
/***
 * Checks whether the language of first automaton is a subset of the language of the second automaton by antichains
 * @param first             the first automaton with its language
 * @param second            the second automaton with its language
 * @return                  true if the language of the first automaton is subset of the language of the second automaton,
 *                              else returns false
 */
bool chain_part(const std::shared_ptr <det_auto>& first, const std::shared_ptr <det_auto>& second);
/***
 * Checks whether the two given automata define the same language through antichains, does not require creating
 * complements, uses chain_part and check_product
 * @param sat           the result automaton with its language
 * @param orig          the original automaton with its language
 * @return              true if the languages of the automata are equal
 */
bool sat_anticahin(const std::shared_ptr <det_auto>& sat, const std::shared_ptr <det_auto>& orig);

#endif //BAKALARKA_AUTO_LANGUAGE_CHECK_H
